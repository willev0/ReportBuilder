# BuildInvestorPage.py
# One page per investor (point-anchored layout, same labels/semantics as your consolidated builder):
# - Top navy band with title / quarter
# - Donut chart (PNG generated by donut.py — SAME method) with centered "Total Capital Invested"
# - KPI numbers in the band (same color logic + same anchor labels)
# - II table (with centered pill buttons) including "Total Equity Raised" column
# Page height auto-expands to fit the table, while header content stays locked to the band.

import os, re, io, shutil, importlib.util, inspect
from dataclasses import dataclass
from typing import List, Tuple, Optional, Dict, Any
from datetime import date
import tomllib
import pandas as pd

from reportlab.pdfgen import canvas
from reportlab.lib import colors
from reportlab.lib.utils import ImageReader, simpleSplit
from reportlab.platypus import Table, TableStyle, Paragraph, Flowable, Spacer
from reportlab.lib.styles import ParagraphStyle
from reportlab.lib.enums import TA_CENTER
from reportlab.pdfbase import pdfmetrics
from reportlab.pdfbase.ttfonts import TTFont
from pathlib import Path

# =======================
# CONFIG
# =======================
HERE = Path(__file__).parent

def _load_cfg(path: str | None = None) -> dict:
    # look for config.toml in Configs/ relative to this file
    cfg_path = HERE / "Configs" / "config.toml"
    if cfg_path.exists():
        with open(cfg_path, "rb") as f:
            return tomllib.load(f)
    return {}

_cfg = _load_cfg()

# -------- Paths (match your config keys) --------
EXCEL_PATH   = str(HERE / _cfg.get("paths", {}).get("excel", "InvestorDataTest.xlsx"))
OUTPUT_DIR   = str(HERE / _cfg.get("paths", {}).get("out_consolidated", "2ConsolidatedStatementPage"))
DONUT_DIR    = str(HERE / _cfg.get("paths", {}).get("donut_dir", "charts"))  # SAME folder the consolidated builder uses

# -------- Fonts --------
FONT_BOLD_NAME = _cfg.get("fonts", {}).get("bold_name", "HKGrotesk-Bold")
FONT_MED_NAME  = _cfg.get("fonts", {}).get("medium_name", "HKGrotesk-Medium")
FONT_BOLD_PATH = str(HERE / _cfg.get("fonts", {}).get("bold_path", "Configs/hk-grotesk.bold.ttf"))
FONT_MED_PATH  = str(HERE / _cfg.get("fonts", {}).get("medium_path", "Configs/hk-grotesk.medium.ttf"))
FONT_BOLD_CANDIDATES = [FONT_BOLD_PATH, str(HERE / "hk-grotesk.bold.ttf")]
FONT_MED_CANDIDATES  = [FONT_MED_PATH,  str(HERE / "hk-grotesk.medium.ttf")]

# -------- Brand/colors --------
NAVY         = colors.HexColor(_cfg.get("brand", {}).get("navy",   "#2A3652"))
ACCENT_GRN   = colors.HexColor(_cfg.get("brand", {}).get("accent", "#A7C9B4"))
HEADER_BG    = colors.HexColor(_cfg.get("brand", {}).get("header_bg", "#54607A"))
ROW_BG       = colors.HexColor(_cfg.get("brand", {}).get("row_bg",    "#C7DCE9"))
LABEL_BG     = colors.HexColor(_cfg.get("brand", {}).get("label_bg",  "#B4D1BE"))
GRID_WHITE   = colors.white
COMPANY_LABEL= _cfg.get("brand", {}).get("company_label", "ESSENTIA CAPITAL")

# KPI/number colors (same meaning as consolidated builder)
NUM_COLOR  = colors.HexColor(_cfg.get("brand", {}).get("accent", "#A7C9B4"))  # small values in band

# Pill button colors
PILL_BG  = colors.HexColor((_cfg.get("brand", {}).get("pill_bg") or _cfg.get("brand", {}).get("header_bg", "#54607A")))
PILL_TXT = colors.white

# -------- Reporting --------
YIELD_IS_ANNUAL = False

# -------- Page geometry (POINTS; 72pt = 1in) --------
PAGE_WIDTH_PT = 612  # Letter width (8.5in * 72)

# MARGINS — point style
LEFT_MARGIN   = 54   # 0.75in
RIGHT_MARGIN  = 54   # 0.75in
BOTTOM_MARGIN = 46   # 0.50in

# =======================
# TOP BAND (POINT-BASED; same semantics preserved)
# =======================
TOP_BAND_H        = 360
ACCENT_LINE_THICK = 2
ACCENT_LINE_W     = 290
ACCENT_LINE_Y_OFF = 305
ACCENT_LINE_X_OFF = -90

TITLE_FONT_SIZE   = 42
TITLE_L1_Y_OFF    = 250
TITLE_L2_Y_OFF    = 200
QUARTER_FONT_SIZE = 12
QUARTER_Y_OFF     = 302
QUARTER_X_OFF     = -26

# =======================
# KPI ANCHORS (band-relative; SAME labels/meaning as consolidated builder)
# =======================
KPI_VALUE_FS  = 24
KPI_LABEL_FS  = 11
SECOND_ROW_VALUE_FS = KPI_VALUE_FS - 2
ROW_SEPARATOR_Y_OFFSET = 18   # pixels below the top KPI values

KPI_ROW_GAP   = 28

# baselines are distances UP from band bottom
KPI_ROW1_FROM_BAND_BOTTOM = 130
KPI_ROW2_FROM_BAND_BOTTOM = KPI_ROW1_FROM_BAND_BOTTOM - (KPI_ROW_GAP + 47)

# =======================
# DONUT (SAME METHOD as consolidated builder) — anchored to band & page-right
# Also: centered value text inside donut.
# =======================
DONUT_DIAMETER = 360
DONUT_TOP_INSET_FROM_BAND_TOP     = 40
DONUT_RIGHT_INSET_FROM_PAGE_RIGHT = -85

DONUT_CENTER_VALUE_FS  = 18
DONUT_CENTER_LABEL_FS  = 10

DONUT_TEXT_MAX_W       = 70   # max width (pt) for wrapping the text inside the donut
DONUT_TEXT_LEADING_VAL = 22    # line height for the value
DONUT_TEXT_LEADING_LAB = 12    # line height for the label
DONUT_TEXT_GAP         = -5    # gap between value block and label block


# =======================
# TABLE LAYOUT (point-based widths/heights)
# =======================
TABLE_TITLE_FS    = 32
TABLE_HEADER_H    = 60
TABLE_ROW_H       = 50
CELL_GAP_PT       = 3
CELL_BORDER_PT    = 1.5
CELL_PAD_X_PT     = 8
CELL_PAD_Y_PT     = 12
TABLE_HEADER_FS   = 12
TABLE_BODY_FS     = 12
DIST_GAP_PT       = 3  # vertical gap between "To Date" block and "Quarter" block

# 7 columns (Name | Amount Invested | Total Equity Raised | Date | Distributions | Yield | NAV)
COLS              = [0.18, 0.14, 0.12, 0.16, 0.18, 0.09, 0.13]

# Pill typography & spacing
BUTTON_FONT_SIZE     = 10
BUTTON_PAD_X_PT      = 10
BUTTON_PAD_Y_PT      = 6
BUTTON_GAP_ABOVE_PT  = 16
BUTTON_GAP_BELOW_PT  = 8
BUTTON_TEXT_BASELINE_ADJ = 1.2  # optical nudge

# gap before table (below the band)
GAP_BEFORE_TABLE  = 75

# =======================
# Utils
# =======================
def _register_font_or_fallback(name: str, candidates: list, fallback: str) -> str:
    for p in candidates:
        if os.path.exists(p):
            try:
                pdfmetrics.registerFont(TTFont(name, p))
                print(f"[font] Using {p}")
                return name
            except Exception as e:
                print(f"[font] Failed to load {p}: {e}")
    print(f"[font] Falling back to {fallback}")
    return fallback

def _norm(s: str) -> str:
    return re.sub(r"\s+", " ", str(s).strip().lower())

def _simp(s: str) -> str:
    return re.sub(r"[^a-z0-9 ]", "", _norm(s))

def _find_col(cols: List[str], *aliases) -> Optional[str]:
    norm = { _norm(c): c for c in cols }
    for a in aliases:
        if a in norm: return norm[a]
    simple = { _simp(k): v for k, v in norm.items() }
    for a in aliases:
        aa = _simp(a)
        if aa in simple: return simple[aa]
    return None

def _fmt_money_full(v) -> str:
    """Full dollars with commas (for Distributions column)."""
    if pd.isna(v) or str(v).strip() == "":
        return ""
    try:
        return f"${float(str(v).replace(',', '').replace('$','')):,.0f}"
    except Exception:
        return str(v)
    
def _fmt_pct_clean(v):
    if pd.isna(v):
        return ""
    try:
        v = float(v)
    except:
        return str(v)

    if v.is_integer():          # whole number like 5.0
        return f"{int(v)}%"
    elif (v * 10).is_integer(): # one decimal place is enough, e.g. 4.5
        return f"{v:.1f}%"
    else:                       # otherwise, keep two decimals max
        return f"{v:.2f}%"
    
def _fmt_money_abbrev(v) -> str:
    """Abbreviated dollars for Amount Invested / Total Equity Raised / NAV."""
    if pd.isna(v) or str(v).strip() == "":
        return ""
    try:
        n = float(str(v).replace(',', '').replace('$',''))
    except Exception:
        return str(v)
    sign = "-" if n < 0 else ""
    n = abs(n)
    if n >= 1_000_000_000:
        s = f"{n/1_000_000_000:.2f}B"
    elif n >= 1_000_000:
        s = f"{n/1_000_000:.2f}M"
    elif n >= 1_000:
        s = f"{n/1_000:.0f}k"
    else:
        s = f"{n:.0f}"
    # trim trailing .00 on B/M
    s = re.sub(r"\.00([BM])$", r"\1", s)
    return f"{sign}${s}"

def _fmt_money_abbr_pretty(x) -> str:
    """Abbreviate money nicely: $300k, $392k, $1.32M, $10.4M, always scaled correctly."""
    try:
        n = float(str(x).replace(",", "").replace("$", "").strip())
    except Exception:
        return str(x)

    sign = "-" if n < 0 else ""
    n = abs(n)

    if n >= 1e9:
        v = n / 1e9
        suffix = "B"
    elif n >= 1e6:
        v = n / 1e6
        suffix = "M"
    elif n >= 1e3:
        v = n / 1e3
        suffix = "k"
    else:
        v = n
        suffix = ""

    # formatting logic: max 3 digits before suffix
    if v >= 100:
        s = f"{int(round(v))}"
    elif v >= 10:
        s = f"{v:.1f}"
    else:
        s = f"{v:.2f}"

    # only trim trailing zeros if there's a decimal point
    if "." in s:
        s = s.rstrip("0").rstrip(".")
    return f"{sign}${s}{suffix}"



def _fmt_date(v) -> str:
    if pd.isna(v) or str(v).strip() == "":
        return ""
    from dateutil.parser import parse as parse_date
    try:
        return parse_date(str(v)).strftime("%-m/%-d/%Y")
    except Exception:
        return str(v)

def _safe_slug(text: str) -> str:
    s = "".join(ch if ch.isalnum() else "_" for ch in str(text).strip())
    while "__" in s:
        s = s.replace("__", "_")
    return s.strip("_") or "chart"

# =======================
# Config-driven URL + display-name helpers
# =======================
def _config_maps(cfg: dict):
    funds = cfg.get("funds", []) or []
    key_to_name, name_to_key, key_to_url = {}, {}, {}
    for f in funds:
        k = str(f.get("key", "")).strip()
        nm = str(f.get("name", "")).strip()
        url = str(f.get("url", "") or "").strip()
        if k:
            if nm:
                key_to_name[k] = nm
                name_to_key[_norm(nm)] = k
            if url:
                key_to_url[k] = url
    for nm, k in (cfg.get("fund_key_map", {}) or {}).items():
        if k:
            name_to_key[_norm(str(nm))] = str(k)
    for k, url in (cfg.get("fund_urls", {}) or {}).items():
        if str(url).strip():
            key_to_url[str(k)] = str(url).strip()
    urls_by_name = {str(k): str(v) for k, v in (cfg.get("fund_urls_by_name", {}) or {}).items()}
    return name_to_key, key_to_url, key_to_name, urls_by_name

def _url_for_investment_name(value: str, cfg: dict) -> str:
    s = str(value or "").strip()
    if not s: return ""
    name_to_key, key_to_url, key_to_name, urls_by_name = _config_maps(cfg)
    if s in urls_by_name: return urls_by_name[s]
    if s in key_to_url:   return key_to_url[s]
    k = name_to_key.get(_norm(s))
    if k and k in key_to_url: return key_to_url[k]
    for k2, nm in key_to_name.items():
        if nm.lower() == s.lower() and k2 in key_to_url:
            return key_to_url[k2]
    return ""

def _display_name_for(value: str, cfg: dict) -> str:
    s = str(value or "").strip()
    if not s: return s
    _, _, key_to_name, _ = _config_maps(cfg)
    return key_to_name.get(s, s)

# =======================
# Data load + compute (same logic as your approved II build, with Total Equity Raised)
# =======================
def _pick_main_sheet(sheets: Dict[str, pd.DataFrame]) -> pd.DataFrame:
    candidates = []
    for name, df in sheets.items():
        cols = list(map(str, df.columns))
        inv  = _find_col(cols, "investor name", "investor")
        fund = _find_col(cols, "fund name", "investment name", "fund", "deal")
        amt  = _find_col(cols, "amount ($)", "amount", "amount invested", "commitment", "commitment ($)")
        dat  = _find_col(cols, "date invested", "investment date", "date")
        score = sum(x is not None for x in (inv, fund, amt, dat))
        candidates.append((score, name, df))
    candidates.sort(key=lambda t: t[0], reverse=True)
    return candidates[0][2]

def _get_funddata_sheet(sheets: Dict[str, pd.DataFrame]) -> Optional[pd.DataFrame]:
    for name, df in sheets.items():
        if _norm(name) == "funddata":
            return df
    scored = []
    for name, df in sheets.items():
        cols = list(map(str, df.columns))
        inv  = _find_col(cols, "investor name", "investor")
        fund = _find_col(cols, "fund name", "investment name", "fund", "deal")
        dtd  = _find_col(cols, "distributed to date", "dtd", "dist to date", "ltd distributions")
        qtd  = _find_col(cols, "distributed this quarter", "dist this quarter", "qtd distribution", "qtd")
        yld  = _find_col(cols, "annualized yield", "annualized yield (%)", "yield", "irr", "annual yield")
        nav  = _find_col(cols, "nav", "nav ($)", "current nav", "value", "ending nav", "NAV")
        teq  = _find_col(cols, "total equity raised", "equity raised", "total equity")
        score = sum(x is not None for x in (inv, fund, dtd, qtd, yld, nav, teq))
        scored.append((score, name, df))
    scored.sort(key=lambda t: t[0], reverse=True)
    return scored[0][2] if scored and scored[0][0] >= 3 else None

def _latest_quarter_from_funddata(df_fund: pd.DataFrame) -> tuple[int, int, str]:
    try:
        q = (
            df_fund["Quarter"].dropna().astype(str)
            .str.extract(r"(?P<year>\d{4})-Q(?P<q>[1-4])")
            .dropna()
        )
        q["year"] = q["year"].astype(int)
        q["q"] = q["q"].astype(int)
        q = q.sort_values(["year","q"])
        if q.empty:
            return 2025, 2, "SECOND QUARTER 2025"
        y = int(q.iloc[-1]["year"]); n = int(q.iloc[-1]["q"])
        words = {1:"FIRST",2:"SECOND",3:"THIRD",4:"FOURTH"}[n]
        return y, n, f"{words} QUARTER {y}"
    except Exception:
        return 2025, 2, "SECOND QUARTER 2025"

def _quarter_end(year: int, q: int) -> date:
    return (date(year,3,31) if q==1 else
            date(year,6,30) if q==2 else
            date(year,9,30) if q==3 else
            date(year,12,31))

def _parse_yield_to_fraction(val) -> float:
    if pd.isna(val): return float("nan")
    s = str(val).strip()
    if not s: return float("nan")
    if s.endswith("%"):
        try: return float(s[:-1].strip())/100.0
        except: return float("nan")
    try:
        v = float(s); return v/100.0 if v>1 else v
    except: return float("nan")

def _coalesce_funddata(fund_df: pd.DataFrame) -> pd.DataFrame:
    df = fund_df.copy()
    cols = list(map(str, df.columns))
    inv  = _find_col(cols, "investor name", "investor")
    fund = _find_col(cols, "fund name", "investment name", "fund", "deal")
    dtd  = _find_col(cols, "distributed to date", "dtd", "dist to date", "ltd distributions")
    qtd  = _find_col(cols, "distributed this quarter", "dist this quarter", "qtd distribution", "qtd")
    yld  = _find_col(cols, "annualized yield", "annualized yield (%)", "yield", "irr", "annual yield")
    nav  = _find_col(cols, "nav", "nav ($)", "current nav", "value", "ending nav")
    teq  = _find_col(cols, "total equity raised", "equity raised", "total equity")
    link = _find_col(cols, "drive link", "report link", "report url", "report", "link", "fund report")
    asof = _find_col(cols, "as of", "as-of", "as of date", "valuation date", "report date", "date")
    qtr  = _find_col(cols, "quarter", "qtr")
    df = df.rename(columns={k:v for k,v in {
        inv:  "Investor" if inv else None,
        fund: "Investment Name" if fund else None,
        dtd:  "Distributed to Date" if dtd else None,
        qtd:  "Distributed this Quarter" if qtd else None,
        yld:  "Annualized Yield" if yld else None,
        nav:  "NAV",
        teq:  "Total Equity Raised" if teq else None,
        link: "Report Link" if link else None,
        asof: "As Of" if asof else None,
        qtr:  "Quarter" if qtr else None,
    }.items() if k})
    keep = [c for c in ["Investor","Investment Name","Distributed to Date",
                        "Distributed this Quarter","Annualized Yield","NAV",
                        "Total Equity Raised","Report Link","As Of","Quarter"] if c in df.columns]
    df = df[keep].copy()
    agg = {}
    if "Distributed to Date" in df.columns:      agg["Distributed to Date"] = "sum"
    if "Distributed this Quarter" in df.columns: agg["Distributed this Quarter"] = "sum"
    if "NAV" in df.columns:                      agg["NAV"] = "last"
    if "Total Equity Raised" in df.columns:      agg["Total Equity Raised"] = "last"
    if "Annualized Yield" in df.columns:         agg["Annualized Yield"] = "last"
    if "Report Link" in df.columns:              agg["Report Link"] = "last"
    keys = [c for c in ["Investor","Investment Name"] if c in df.columns]
    if not agg: return df.drop_duplicates(subset=keys)[keys]
    return df.groupby(keys, as_index=False).agg(agg)

def _load_data(excel_path: str) -> pd.DataFrame:
    sheets = pd.read_excel(excel_path, sheet_name=None)
    main_df = _pick_main_sheet(sheets).copy()
    main_cols = list(map(str, main_df.columns))
    inv_col  = _find_col(main_cols, "investor name", "investor")
    fund_col = _find_col(main_cols, "fund name", "investment name", "fund", "deal")
    amt_col  = _find_col(main_cols, "amount ($)", "amount", "amount invested", "commitment", "commitment ($)")
    date_col = _find_col(main_cols, "date invested", "investment date", "date")

    base = pd.DataFrame({
        "Investor": main_df[inv_col].astype(str).str.strip(),
        "Investment Name": main_df[fund_col].astype(str).str.strip(),
        "Amount Invested": main_df[amt_col],
        "Date": main_df[date_col],
    })

    fd_sheet = _get_funddata_sheet(sheets)
    if fd_sheet is not None:
        fd_reduced = _coalesce_funddata(fd_sheet)
        merged = base.merge(fd_reduced, on=[c for c in ["Investor","Investment Name"] if c in fd_reduced.columns], how="left")
        y, n, quarter_text_for_header = _latest_quarter_from_funddata(fd_sheet)
    else:
        merged = base.copy()
        merged["Distributed to Date"] = float("nan")
        merged["Distributed this Quarter"] = float("nan")
        merged["Annualized Yield"] = float("nan")
        merged["NAV"] = float("nan")
        merged["Total Equity Raised"] = float("nan")
        merged["Report Link"] = ""
        y, n, quarter_text_for_header = 2025, 2, "SECOND QUARTER 2025"

    # --- Investor NAV calculation: owner % × latest FUND NAV using FundData ---

    # Investor commitment (numeric)
    amt_num = pd.to_numeric(
        merged["Amount Invested"].astype(str).str.replace(r"[^0-9.\-]", "", regex=True),
        errors="coerce"
    ).fillna(0.0)

    # Build latest-per-fund snapshot from FundData
    _FUND_SNAPSHOT = pd.DataFrame({"Investment Name": [], "_FundNAV": [], "_FundEquity": []})
    if fd_sheet is not None and not fd_sheet.empty:
        cols = list(map(str, fd_sheet.columns))
        fcol = _find_col(cols, "fund name", "investment name", "fund", "deal")
        ncol = _find_col(cols, "nav", "nav ($)", "current nav", "value", "ending nav")
        ecol = _find_col(cols, "total equity raised", "equity raised", "total equity")
        qcol = _find_col(cols, "quarter", "qtr")
        acol = _find_col(cols, "as of", "as-of", "as of date", "valuation date", "report date", "date")

        use_cols = [c for c in [fcol, ncol, ecol, qcol, acol] if c]
        snap = fd_sheet[use_cols].copy().rename(columns={
            fcol: "Investment Name",
            ncol: "_FundNAV_raw",
            ecol: "_FundEquity_raw",
        })
        snap["Investment Name"] = snap["Investment Name"].astype(str).str.strip()

        # numeric NAV / Equity (strip commas/$)
        for cc in ["_FundNAV_raw", "_FundEquity_raw"]:
            if cc in snap.columns:
                snap[cc] = pd.to_numeric(
                    snap[cc].astype(str).str.replace(r"[^0-9.\-]", "", regex=True),
                    errors="coerce"
                )

        # choose "latest" row per fund via Quarter or As-Of
        snap["_sortkey"] = 0
        if qcol:
            qparts = snap[qcol].astype(str).str.extract(r"(?P<y>\d{4})-?Q(?P<q>[1-4])")
            _y_series = pd.to_numeric(qparts["y"], errors="coerce")
            _q_series = pd.to_numeric(qparts["q"], errors="coerce")
            mask_q = _y_series.notna() & _q_series.notna()
            snap.loc[mask_q, "_sortkey"] = (_y_series * 4 + _q_series)

        if acol:
            asof_dt = pd.to_datetime(snap[acol], errors="coerce")
            asof_ord = asof_dt.astype("int64")
            mask_asof = (snap["_sortkey"] == 0) & asof_dt.notna()
            snap.loc[mask_asof, "_sortkey"] = asof_ord[mask_asof]

        # take latest per fund
        idx = snap.groupby("Investment Name")["_sortkey"].idxmax()
        latest = snap.loc[idx, ["Investment Name", "_FundNAV_raw", "_FundEquity_raw"]].copy()
        latest = latest.rename(columns={"_FundNAV_raw": "_FundNAV", "_FundEquity_raw": "_FundEquity"})
        _FUND_SNAPSHOT = latest

    # attach latest fund NAV + fund Total Equity to investor rows
    merged = merged.merge(_FUND_SNAPSHOT, on="Investment Name", how="left")
    merged["_FundNAV"] = merged["_FundNAV"].fillna(0.0)
    merged["_FundEquity"] = merged["_FundEquity"].replace({0: pd.NA})

    # ownership % = investor amount / fund total equity (latest)
    owner_pct = (amt_num / merged["_FundEquity"]).fillna(0.0)

    # investor NAV = ownership % × fund NAV (latest)
    fund_nav_total = merged["_FundNAV"].fillna(0.0)
    merged["NAV"] = (owner_pct * fund_nav_total).fillna(0.0)




    # Distributions calc  (REPLACEMENT: pure Excel-driven, with partial-quarter proration; NO fallbacks)
    with pd.option_context('mode.chained_assignment', None):
        from pandas import to_datetime

        merged["_DateParsed"] = to_datetime(merged["Date"], errors="coerce")
        merged["_AsOf"]       = pd.to_datetime(_quarter_end(y, n))  # end of as-of quarter

        # --- Build per-fund, per-quarter yield map directly from FundData sheet ---
        yields_map: Dict[tuple, float] = {}
        if fd_sheet is not None and not fd_sheet.empty:
            cols = list(map(str, fd_sheet.columns))
            fcol = _find_col(cols, "fund name", "investment name", "fund", "deal")
            qcol = _find_col(cols, "quarter", "qtr")
            ycol = _find_col(cols, "annualized yield", "annualized yield (%)", "yield", "irr", "annual yield")

            if fcol and qcol and ycol:
                ydf = fd_sheet[[fcol, qcol, ycol]].copy()
                ydf.columns = ["Investment Name", "Quarter", "Yield"]
                ydf["Investment Name"] = ydf["Investment Name"].astype(str).str.strip()

                # quarter → (year, q)
                qm = ydf["Quarter"].astype(str).str.extract(r"(?P<year>\d{4})-?Q(?P<q>[1-4])")
                ydf["_y"] = pd.to_numeric(qm["year"], errors="coerce")
                ydf["_q"] = pd.to_numeric(qm["q"], errors="coerce")

                # parse to fraction and convert to per-quarter if config says 'annual'
                ydf["YieldFrac"] = ydf["Yield"].apply(_parse_yield_to_fraction)
                ydf["QtrYieldFrac"] = ydf["YieldFrac"] / 4.0 if YIELD_IS_ANNUAL else ydf["YieldFrac"]

                ydf = ydf.dropna(subset=["_y", "_q", "QtrYieldFrac"])
                for _, rr in ydf.iterrows():
                    yields_map[(str(rr["Investment Name"]).strip(), int(rr["_y"]), int(rr["_q"]))] = float(rr["QtrYieldFrac"])

        # --- quarter helpers ---
        def _yq_from_dt(dt: pd.Timestamp) -> tuple[int, int]:
            return (int(dt.year), int(((dt.month - 1) // 3) + 1))

        def _qindex(yy: int, qq: int) -> int:
            return int(yy) * 4 + int(qq)

        def _qstart(yy: int, qq: int) -> pd.Timestamp:
            m = {1: 1, 2: 4, 3: 7, 4: 10}[int(qq)]
            return pd.Timestamp(int(yy), m, 1)

        def _qend(yy: int, qq: int) -> pd.Timestamp:
            d = _quarter_end(int(yy), int(qq))
            return pd.Timestamp(d.year, d.month, d.day)

        def _days_in_q(yy: int, qq: int) -> int:
            return (_qend(yy, qq) - _qstart(yy, qq)).days + 1

        # --- compute QTD/LTD using ONLY FundData yields (per quarter); first quarter is prorated ---
        def _compute_from_timeseries(row) -> tuple[float, float, float]:
            inv_dt = row["_DateParsed"]
            if pd.isna(inv_dt):
                return 0.0, 0.0, 0.0

            asof_dt = row["_AsOf"]
            if pd.isna(asof_dt) or (inv_dt > asof_dt):
                return 0.0, 0.0, 0.0

            fund = str(row["Investment Name"]).strip()
            amt  = pd.to_numeric(row["Amount Invested"], errors="coerce")
            if pd.isna(amt):
                amt = 0.0

            ys, qs = _yq_from_dt(inv_dt)
            ya, qa = y, n
            i1, i2 = _qindex(ys, qs), _qindex(ya, qa)

            # yield for as-of quarter (if missing in sheet → zero; still purely sheet-driven)
            asof_q_yield = yields_map.get((fund, ya, qa), 0.0)

            # QTD
            if i2 < i1:
                qtd = 0.0
            elif i2 == i1:
                days_q = _days_in_q(ya, qa)
                qe     = _qend(ya, qa)
                frac   = max(0.0, min(1.0, ((qe - inv_dt).days + 1) / days_q))
                qtd    = amt * asof_q_yield * frac
            else:
                qtd = amt * asof_q_yield  # invested before as-of quarter → full quarter

            # LTD (sum across quarters, first quarter prorated)
            ltd = 0.0
            if i2 >= i1:
                for idx in range(i1, i2 + 1):
                    yy = idx // 4
                    qq = idx % 4
                    if qq == 0:
                        yy -= 1
                        qq = 4
                    yy = int(yy); qq = int(qq)

                    yld = yields_map.get((fund, yy, qq), 0.0)
                    if idx == i1:
                        days_q = _days_in_q(yy, qq)
                        qe     = _qend(yy, qq)
                        frac   = max(0.0, min(1.0, ((qe - inv_dt).days + 1) / days_q))
                    else:
                        frac   = 1.0
                    ltd += amt * yld * frac

            return float(qtd), float(ltd), float(asof_q_yield)

        res = merged.apply(_compute_from_timeseries, axis=1, result_type="expand")
        merged["_QTD_num"]  = res[0].astype(float).fillna(0.0)
        merged["_DTD_num"]  = res[1].astype(float).fillna(0.0)
        merged["_QtrYield"] = res[2].astype(float).fillna(0.0)


    # Formats:
    merged["Amount Invested"] = pd.to_numeric(
        merged["Amount Invested"].astype(str).str.replace(r"[^0-9.\-]", "", regex=True),
        errors="coerce"
    ).fillna(0.0)

    # Keep numeric columns available for later sums and format at render time:
    merged["NAV"]  = pd.to_numeric(merged["NAV"].astype(str).str.replace(r"[^0-9.\-]", "", regex=True), errors="coerce").fillna(0.0)
    merged["Total Equity Raised"] = pd.to_numeric(merged["Total Equity Raised"].astype(str).str.replace(r"[^0-9.\-]", "", regex=True), errors="coerce")
    merged["Date"] = merged["_DateParsed"].apply(_fmt_date)
    merged["Distributed to Date"] = merged["_DTD_num"].map(_fmt_money_full)
    merged["Distributed this Quarter"] = merged["_QTD_num"].map(_fmt_money_full)
    annualized_from_q = (merged["_QtrYield"] * 4.0 * 100.0)
    merged["Annualized Yield"] = annualized_from_q.map(_fmt_pct_clean)

    # URL overlay + display name
    if "Report Link" not in merged.columns: merged["Report Link"] = ""
    def _overlay_url(row):
        return str(row.get("Report Link","") or "").strip()
    merged["Report Link"] = merged.apply(_overlay_url, axis=1).astype(str)
    merged["Report Link"] = merged["Report Link"].apply(lambda u: u if u and u.lower() not in ("nan","none") else "")
    merged["Display Name"] = merged["Investment Name"].apply(lambda v: _display_name_for(v, _cfg))

    # keep numeric helpers for KPIs (_QTD_num/_DTD_num); drop other scratch cols
    _cols_keep = {"_QTD_num", "_DTD_num"}
    merged = merged.drop(columns=[c for c in merged.columns if c.startswith("_") and c not in _cols_keep],
                        errors="ignore")
    merged.attrs["quarter_text_for_header"] = _latest_quarter_from_funddata(fd_sheet)[2] if fd_sheet is not None else "SECOND QUARTER 2025"
    merged.attrs["asof_year"] = y
    merged.attrs["asof_q"]    = n
    return merged.sort_values(["Investor", "Investment Name"], kind="stable").reset_index(drop=True)

# =======================
# Styles
# =======================
P_STYLE_HEADER = ParagraphStyle(
    name="TableHeaderCenter",
    alignment=TA_CENTER,
    fontName=FONT_MED_NAME,
    fontSize=TABLE_HEADER_FS,
    leading=TABLE_HEADER_FS + 3,
    textColor=colors.white,
    splitLongWords=False,
)
P_STYLE_BODY = ParagraphStyle(
    name="TableBodyCenter",
    alignment=TA_CENTER,
    fontName=FONT_MED_NAME,
    fontSize=TABLE_BODY_FS,
    leading=TABLE_BODY_FS + 3,
    splitLongWords=False,
)
P_STYLE_NAME = ParagraphStyle(
    name="FundName",
    parent=P_STYLE_BODY,
)
DIST_STYLE = ParagraphStyle(
    name="DistStyle",
    parent=P_STYLE_BODY,
    alignment=TA_CENTER,
    leading=TABLE_BODY_FS + 2,
)

def _apply_styles_fonts(font_med_name: str):
    for s in (P_STYLE_HEADER, P_STYLE_BODY, P_STYLE_NAME, DIST_STYLE):
        s.fontName = font_med_name

# =======================
# Pill Button Flowable
# =======================
class PillButton(Flowable):
    def __init__(self, label: str, url: str,
                 fontName: str, fontSize: float,
                 pad_x: float, pad_y: float,
                 bg_color, txt_color):
        super().__init__()
        self.label = label
        self.url = (url or "").strip()
        self.fontName = fontName
        self.fontSize = fontSize
        self.pad_x = pad_x
        self.pad_y = pad_y
        self.bg = bg_color
        self.txt = txt_color
        self._avail_w = None
        self._btn_w = None
        self._btn_h = None

    def wrap(self, availWidth, availHeight):
        self._avail_w = availWidth
        text_w = pdfmetrics.stringWidth(self.label, self.fontName, self.fontSize)
        self._btn_w = text_w + 2 * self.pad_x
        self._btn_h = self.fontSize + 2 * self.pad_y
        return (availWidth, self._btn_h)

    def draw(self):
        if not self.url:
            return
        c = self.canv
        w, h = self._btn_w, self._btn_h
        x = (self._avail_w - w) / 2.0
        y = 0
        r = h / 2.0
        c.saveState()
        c.setFillColor(PILL_BG)
        c.roundRect(x, y, w, h, r, fill=1, stroke=0)
        c.setFillColor(PILL_TXT)
        c.setFont(self.fontName, self.fontSize)
        tx = x + self.pad_x
        ty = y + (h - self.fontSize) / 2.0 + BUTTON_TEXT_BASELINE_ADJ
        c.drawString(tx, ty, self.label)
        c.linkURL(self.url, (x, y, x + w, y + h), relative=1)
        c.restoreState()

# =======================
# First column: name + pill (stacked)
# =======================
def _name_cell(display_name: str, url: str, col_width: float):
    name_para = Paragraph(str(display_name or ""), P_STYLE_NAME)
    url = (url or "").strip()
    if not url or url.lower() in ("nan","none"):
        inner = Table([[name_para]], colWidths=[col_width])
        inner.setStyle(TableStyle([
            ("VALIGN", (0,0), (-1,-1), "MIDDLE"),
            ("ALIGN",  (0,0), (-1,-1), "CENTER"),
            ("LEFTPADDING",  (0,0), (-1,-1), 0),
            ("RIGHTPADDING", (0,0), (-1,-1), 0),
            ("TOPPADDING",   (0,0), (-1,-1), 0),
            ("BOTTOMPADDING",(0,0), (-1,-1), 0),
        ]))
        return inner

    gap_above = max(0, float(BUTTON_GAP_ABOVE_PT))
    gap_below = max(0, float(BUTTON_GAP_BELOW_PT))
    pill = PillButton("View Report", url, P_STYLE_BODY.fontName, BUTTON_FONT_SIZE,
                      BUTTON_PAD_X_PT, BUTTON_PAD_Y_PT, PILL_BG, PILL_TXT)
    inner = Table([[name_para],
                   [Spacer(1, gap_above)],
                   [pill],
                   [Spacer(1, gap_below)]],
                  colWidths=[col_width],
                  rowHeights=[None, gap_above, None, gap_below])
    inner.setStyle(TableStyle([
        ("VALIGN", (0,0), (-1,-1), "MIDDLE"),
        ("ALIGN",  (0,0), (-1,-1), "CENTER"),
        ("LEFTPADDING",  (0,0), (-1,-1), 0),
        ("RIGHTPADDING", (0,0), (-1,-1), 0),
        ("TOPPADDING",   (0,0), (-1,-1), 0),
        ("BOTTOMPADDING",(0,0), (-1,-1), 0),
        ("BOX", (0,0), (-1,-1), 0, colors.transparent),
        ("INNERGRID", (0,0), (-1,-1), 0, colors.transparent),
    ]))
    return inner

# =======================
# Table build + measure
# =======================
def _compute_col_widths(area_w: float) -> List[float]:
    total = sum(COLS)
    return [area_w * (p/total) for p in COLS]

def _prepare_table_cells_and_heights(rows, col_widths, asof_q):
    header_labels = [f"Q{asof_q} Fund Reports", "Amount Invested", "Total Equity Raised", "Date Invested",
                     "Distributions", "Yield", "NAV"]
    header_row = [Paragraph(h, P_STYLE_HEADER) for h in header_labels]

    body_rows = []
    for r in rows:
        cells = []
        for ci, v in enumerate(r):
            if ci == 0 and isinstance(v, dict) and "name" in v:
                # name + pill
                nm, url = v.get("name",""), v.get("url","")
                cells.append(_name_cell(nm, url, col_widths[0] - 2 * CELL_PAD_X_PT))
            elif ci == 4 and isinstance(v, dict) and v.get("__dist_cell__"):
                # Distributions inner stack with adjustable gap
                dtd = v.get("dtd", "$0")
                qtd = v.get("qtd", "$0")
                inner_parts = [
                    [Paragraph("To Date:", DIST_STYLE)],
                    [Paragraph(dtd,       DIST_STYLE)],
                    [Spacer(1, DIST_GAP_PT)],                 # <— adjustable gap
                    [Paragraph(f"Q{asof_q}:", DIST_STYLE)],
                    [Paragraph(qtd,        DIST_STYLE)],
                ]
                inner_w = max(0.0, col_widths[4] - 2 * CELL_PAD_X_PT)
                inner = Table(inner_parts, colWidths=[inner_w])
                inner.setStyle(TableStyle([
                    ("VALIGN", (0,0), (-1,-1), "MIDDLE"),
                    ("ALIGN",  (0,0), (-1,-1), "CENTER"),
                    ("LEFTPADDING",  (0,0), (-1,-1), 0),
                    ("RIGHTPADDING", (0,0), (-1,-1), 0),
                    ("TOPPADDING",   (0,0), (-1,-1), 0),
                    ("BOTTOMPADDING",(0,0), (-1,-1), 0),
                    ("BOX", (0,0), (-1,-1), 0, colors.transparent),
                    ("INNERGRID", (0,0), (-1,-1), 0, colors.transparent),
                ]))
                cells.append(inner)
            else:
                txt = "" if v is None else str(v)
                cells.append(Paragraph(txt, P_STYLE_BODY))
        body_rows.append(cells)

    data = [header_row] + body_rows

    row_heights = []
    for r_idx, row in enumerate(data):
        heights = []
        for c_idx, cell in enumerate(row):
            wrap_w = max(0.0, col_widths[c_idx] - 2 * CELL_PAD_X_PT)
            _, h = cell.wrap(wrap_w, 10**6)
            heights.append(h)
        content_h = max(heights) if heights else 0.0
        rh = max(content_h + 2 * CELL_PAD_Y_PT, TABLE_HEADER_H if r_idx==0 else TABLE_ROW_H)
        row_heights.append(rh)
    return data, row_heights

def build_table(rows: List[List[Any]], area_w: float, asof_q: int) -> Tuple[Table, float]:
    col_widths = _compute_col_widths(area_w)
    data, row_heights = _prepare_table_cells_and_heights(rows, col_widths, asof_q)
    tbl = Table(data, colWidths=col_widths, rowHeights=row_heights, repeatRows=1)
    tbl.setStyle(TableStyle([
        ("BACKGROUND", (0, 0), (-1, 0), HEADER_BG),
        ("TEXTCOLOR", (0, 0), (-1, 0), colors.white),

        ("BACKGROUND", (1, 1), (-1, -1), ROW_BG),
        ("BACKGROUND", (0, 1), (0, -1), LABEL_BG),

        ("ALIGN", (0, 0), (-1, -1), "CENTER"),
        ("VALIGN", (0, 0), (-1, -1), "MIDDLE"),

        ("BOX", (0, 0), (-1, -1), CELL_BORDER_PT, GRID_WHITE),
        ("INNERGRID", (0, 0), (-1, -1), CELL_GAP_PT, GRID_WHITE),

        ("LEFTPADDING",  (0, 0), (-1, -1), CELL_PAD_X_PT),
        ("RIGHTPADDING", (0, 0), (-1, -1), CELL_PAD_X_PT),
        ("TOPPADDING",   (0, 0), (-1, -1), CELL_PAD_Y_PT),
        ("BOTTOMPADDING",(0, 0), (-1, -1), CELL_PAD_Y_PT),
    ]))
    total_h = sum(row_heights)
    return tbl, total_h

# =======================
# Header band + KPIs + Donut (SAME METHOD as consolidated)
# =======================
def draw_top_band(c: canvas.Canvas, page_h: float, font_bold: str, font_med: str, quarter_text: str):
    # Band background
    c.setFillColor(NAVY)
    c.rect(0, page_h - TOP_BAND_H, PAGE_WIDTH_PT, TOP_BAND_H, fill=1, stroke=0)

    # Accent line
    c.setStrokeColor(ACCENT_GRN)
    c.setLineWidth(ACCENT_LINE_THICK)
    y = page_h - TOP_BAND_H + ACCENT_LINE_Y_OFF
    center_x = (PAGE_WIDTH_PT / 2.0) + ACCENT_LINE_X_OFF
    x1 = center_x - (ACCENT_LINE_W / 2.0)
    x2 = center_x + (ACCENT_LINE_W / 2.0)
    c.line(x1, y, x2, y)

    # Quarter (top-right)
    c.setFillColor(colors.white)
    c.setFont(font_med, QUARTER_FONT_SIZE)
    tw_q = c.stringWidth(quarter_text, font_med, QUARTER_FONT_SIZE)
    c.drawString(PAGE_WIDTH_PT - RIGHT_MARGIN - tw_q + QUARTER_X_OFF,
                 page_h - TOP_BAND_H + QUARTER_Y_OFF,
                 quarter_text)

    # Title (left)
    c.setFont(font_bold, TITLE_FONT_SIZE)
    c.drawString(LEFT_MARGIN, page_h - TOP_BAND_H + TITLE_L1_Y_OFF, "CONSOLIDATED")
    c.drawString(LEFT_MARGIN, page_h - TOP_BAND_H + TITLE_L2_Y_OFF, "STATEMENT")

def draw_kpis_in_band(c: canvas.Canvas, page_h: float, font_bold: str, font_med: str,
                      invested_total: float, nav_total: float, qtd_total: float, ann_yld_text: str,
                      ltd_total: float, asof_q: int, asof_year: int):

    # geometry
    content_w = PAGE_WIDTH_PT - LEFT_MARGIN - RIGHT_MARGIN
    band_bottom = page_h - TOP_BAND_H

    # y positions
    y_top    = band_bottom + KPI_ROW1_FROM_BAND_BOTTOM
    y_bottom = band_bottom + KPI_ROW2_FROM_BAND_BOTTOM

    # x positions: 3 columns for top row (yours)
    x_top = [LEFT_MARGIN - 40,
             LEFT_MARGIN + 80,
             LEFT_MARGIN + 180
    ]

    # x positions: 2 columns for bottom row (yours)
    x_bottom = [LEFT_MARGIN + 15,
                LEFT_MARGIN + 125
    ]

    # ---- per-column tunables (local) ----
    # adjust these numbers per column to control wrap width independently
    top_col_w     = [120, 70, 70]  # [Invested, Distributed to Date, NAV]
    bottom_col_w  = [100, 90]       # [Annualized, Distributed This Quarter]
    label_inset   = 12               # same inset for all; make a list if you want per-col insets too
    val_to_lab_gap = 18
    label_leading  = KPI_LABEL_FS + 2

    # TOP ROW (matches screenshot order)
    top_vals = [
        (_fmt_money_abbr_pretty(invested_total), "Total Capital Invested"),
        (_fmt_money_abbr_pretty(ltd_total),      "Distributed To Date"),
        (_fmt_money_abbr_pretty(nav_total),      "Current NAV"),
    ]

    # draw top row (centered values + wrapped/centered labels)
    for (val, lab), x, col_w in zip(top_vals, x_top, top_col_w):
        center_x = x + (col_w / 2.0)
        label_max_w = max(0.0, col_w - 2 * label_inset)

        c.setFillColor(NUM_COLOR)
        c.setFont(font_bold, KPI_VALUE_FS)
        c.drawCentredString(center_x, y_top, val)

        c.setFillColor(colors.white)
        c.setFont(font_med, KPI_LABEL_FS)
        lines = simpleSplit(lab, font_med, KPI_LABEL_FS, label_max_w)
        y = y_top - val_to_lab_gap
        for ln in lines:
            c.drawCentredString(center_x, y, ln)
            y -= label_leading

    # separator
    c.setStrokeColor(ACCENT_GRN)
    c.setLineWidth(ACCENT_LINE_THICK)
    line_inset_left  = -10
    line_inset_right = 260
    line_y = y_top - ROW_SEPARATOR_Y_OFFSET - 28

    c.line(
        LEFT_MARGIN + line_inset_left,
        line_y,
        LEFT_MARGIN + content_w - line_inset_right,
        line_y
    )
    # bottom values (define before loop)
    bottom_vals = [
        (ann_yld_text or "",              f"Annualized Yield: Q{asof_q} {asof_year}"),
        (_fmt_money_full(qtd_total),      "Distributed This Quarter"),
    ]

    # draw bottom row (centered values + wrapped/centered labels)
    for (val, lab), x, col_w in zip(bottom_vals, x_bottom, bottom_col_w):
        center_x = x + (col_w / 2.0)
        label_max_w = max(0.0, col_w - 2 * label_inset)

        c.setFillColor(NUM_COLOR)
        c.setFont(font_bold, SECOND_ROW_VALUE_FS)  # or KPI_VALUE_FS if you want same size
        c.drawCentredString(center_x, y_bottom, val)

        c.setFillColor(colors.white)
        c.setFont(font_med, KPI_LABEL_FS)
        lines = simpleSplit(lab, font_med, KPI_LABEL_FS, label_max_w)
        y = y_bottom - val_to_lab_gap
        for ln in lines:
            c.drawCentredString(center_x, y, ln)
            y -= label_leading



def draw_donut_png_in_band(c: canvas.Canvas, page_h: float, donut_png_path: str,
                           total_capital_invested: float, font_bold: str, font_med: str):
    """SAME METHOD as consolidated builder: fit PNG within a fixed box anchored to band top + page right.
       Adds centered Total Capital Invested text inside the donut."""
    from PIL import Image
    img = Image.open(donut_png_path)
    iw, ih = img.size
    scale = min(DONUT_DIAMETER / iw, DONUT_DIAMETER / ih)
    w = iw * scale
    h = ih * scale

    # X: anchor from page right
    x_right = PAGE_WIDTH_PT - RIGHT_MARGIN - DONUT_RIGHT_INSET_FROM_PAGE_RIGHT
    x_left  = x_right - w

    # Y: anchor from band top
    band_top = page_h
    y_top    = band_top - DONUT_TOP_INSET_FROM_BAND_TOP
    y_bottom = y_top - h

    # draw donut image
    c.drawImage(ImageReader(img), x_left, y_bottom, width=w, height=h, mask='auto')

        # centered value + label (wrapped)
    cx = x_left + w/2.0
    cy = y_bottom + h/2.0

    value_text = _fmt_money_abbr_pretty(total_capital_invested)
    label_text = "Total Capital Invested"

    # You can make this relative: e.g., max_w = 0.70 * w
    max_w = DONUT_TEXT_MAX_W

    # Break into lines that fit max_w
    val_lines = simpleSplit(value_text, font_bold, DONUT_CENTER_VALUE_FS, max_w)
    lab_lines = simpleSplit(label_text, font_med,  DONUT_CENTER_LABEL_FS, max_w)

    # Compute total block height to vertically center
    val_h = len(val_lines) * DONUT_TEXT_LEADING_VAL
    lab_h = len(lab_lines) * DONUT_TEXT_LEADING_LAB
    total_h = val_h + (DONUT_TEXT_GAP if lab_lines else 0) + lab_h

    y_start = cy + total_h/2.0 +6  # top of the block

    c.setFillColor(colors.white)

    # Draw value lines (centered)
    c.setFont(font_bold, DONUT_CENTER_VALUE_FS)
    y = y_start - DONUT_TEXT_LEADING_VAL
    for line in val_lines:
        tw = c.stringWidth(line, font_bold, DONUT_CENTER_VALUE_FS)
        c.drawString(cx - tw/2.0, y, line)
        y -= DONUT_TEXT_LEADING_VAL

    # Gap
    if lab_lines:
        y -= DONUT_TEXT_GAP

    # Draw label lines (centered)
    c.setFont(font_med, DONUT_CENTER_LABEL_FS)
    for line in lab_lines:
        tw = c.stringWidth(line, font_med, DONUT_CENTER_LABEL_FS)
        c.drawString(cx - tw/2.0, y, line)
        y -= DONUT_TEXT_LEADING_LAB


def draw_footer_brand(c: canvas.Canvas, page_h: float, font_med: str):
    c.setFillColor(NAVY)
    c.setFont(font_med, 9)
    label = COMPANY_LABEL
    twl = c.stringWidth(label, font_med, 9)
    c.drawString(PAGE_WIDTH_PT - RIGHT_MARGIN - twl, max(10, int(BOTTOM_MARGIN*0.45)), label)

# =======================
# Donut generation (EXACT same module call as consolidated)
# =======================
def _load_module_by_path(module_filename: str, modname: str):
    here = os.path.abspath(os.path.dirname(__file__))
    path = os.path.join(here, module_filename)
    if not os.path.exists(path):
        raise SystemExit(f"Expected {module_filename} at: {path}")
    spec = importlib.util.spec_from_file_location(modname, path)
    mod = importlib.util.module_from_spec(spec)
    assert spec and spec.loader
    spec.loader.exec_module(mod)  # type: ignore
    print(f"[{modname}] loaded from {getattr(mod, '__file__', path)}")
    return mod

def _regen_donuts(donut_mod, excel_path: str, out_dir: str):
    if os.path.isdir(out_dir):
        shutil.rmtree(out_dir)
    os.makedirs(out_dir, exist_ok=True)
    fn = getattr(donut_mod, "generate_investor_donuts_from_excel", None)
    if fn is None or not callable(fn):
        public_funcs = sorted(n for n, obj in inspect.getmembers(donut_mod, inspect.isfunction) if not n.startswith("_"))
        raise SystemExit(f"donut.py missing 'generate_investor_donuts_from_excel'. Public functions: {public_funcs}")
    print(f"[donut] generating donuts → {out_dir}")
    fn(excel_path, out_dir, square=True, square_size=900)

# =======================
# MAIN
# =======================
def generate_consolidated_pages(excel_path: str, output_dir: str):
    # Fonts
    font_bold = _register_font_or_fallback(FONT_BOLD_NAME, FONT_BOLD_CANDIDATES, "Helvetica-Bold")
    font_med  = _register_font_or_fallback(FONT_MED_NAME,  FONT_MED_CANDIDATES,  "Helvetica")
    _apply_styles_fonts(font_med)

    # Data
    df = _load_data(excel_path)
    asof_q = df.attrs.get("asof_q", 2)
    asof_year = df.attrs.get("asof_year", 2025)
    quarter_text = df.attrs.get("quarter_text_for_header", "SECOND QUARTER 2025")

    # Donuts (same method)
    donut = _load_module_by_path("donut.py", "donut")
    _regen_donuts(donut, excel_path, DONUT_DIR)
    donut_map = {os.path.splitext(f)[0]: os.path.join(DONUT_DIR, f)
                 for f in os.listdir(DONUT_DIR) if f.lower().endswith(".png")}

    os.makedirs(output_dir, exist_ok=True)

    def num(s):
        return pd.to_numeric(str(s).replace("$","").replace(",",""), errors="coerce")

    for investor, g in df.groupby("Investor", sort=False):
        slug = _safe_slug(investor)
        donut_png = donut_map.get(slug)
        if not donut_png or not os.path.exists(donut_png):
            print(f"[warn] no donut for '{investor}' (slug '{slug}'); skipping.")
            continue

        # ---- totals for KPIs & donut center ----
        nav_total  = pd.to_numeric(g["NAV"], errors="coerce").fillna(0).sum()
        qtd_total  = g["_QTD_num"].sum()
        ltd_total  = g["_DTD_num"].sum()
        invested   = pd.to_numeric(g["Amount Invested"], errors="coerce").fillna(0).sum()


        # Annualized yield display — weight by the investor's allocation (Amount Invested)
        yld_vals = pd.to_numeric(
            g["Annualized Yield"].astype(str).str.rstrip("%"), errors="coerce"
        )
        weights = pd.to_numeric(g["Amount Invested"], errors="coerce").fillna(0)

        mask = yld_vals.notna() & (weights > 0)
        if mask.any():
            wavg = (yld_vals[mask] * weights[mask]).sum() / weights[mask].sum()
            ann_yld_text = _fmt_pct_clean(wavg)  # uses your "5%, 4.5%, 5.43%" formatting
        else:
            ann_yld_text = ""


        # ---- table rows (with abbrev money; Distributions as 4-line block + adjustable gap) ----
        rows = []
        for _, r in g.iterrows():
            amt = _fmt_money_abbrev(r.get("Amount Invested", ""))
            teq = _fmt_money_abbrev(r.get("Total Equity Raised", ""))
            nav = _fmt_money_abbrev(r.get("NAV", ""))

            dtd = (str(r.get("Distributed to Date", "") or "").strip()) or "$0"
            qtd = (str(r.get("Distributed this Quarter", "") or "").strip()) or "$0"

            # We’ll build the actual inner table later (when we know column widths).
            dist_marker = {"__dist_cell__": True, "dtd": dtd, "qtd": qtd}

            rows.append([
                {"name": _display_name_for(r.get("Investment Name",""), _cfg),
                "url":  str(r.get("Report Link","") or "")},
                amt,
                teq,
                str(r.get("Date","")),
                dist_marker,
                str(r.get("Annualized Yield","")),
                nav,
            ])


        # ---- measure table for dynamic page height ----
        content_w = PAGE_WIDTH_PT - LEFT_MARGIN - RIGHT_MARGIN
        tbl, table_h = build_table(rows, content_w, asof_q)

        # Page height = fixed band + gap + table + bottom margin
        page_h = TOP_BAND_H + GAP_BEFORE_TABLE + table_h + BOTTOM_MARGIN

        # ---- render ----
        out_path = os.path.join(output_dir, f"{slug}.pdf")
        c = canvas.Canvas(out_path, pagesize=(PAGE_WIDTH_PT, page_h))

        # Band + KPIs (anchored to band)
        draw_top_band(c, page_h, font_bold, font_med, quarter_text)
        draw_kpis_in_band(
            c, page_h, font_bold, font_med,
            invested, nav_total, qtd_total, ann_yld_text, ltd_total, asof_q, asof_year
        )

        # Donut (anchored to band top + page right) + centered Total Capital Invested
        draw_donut_png_in_band(
            c, page_h, donut_png, total_capital_invested=invested,
            font_bold=font_bold, font_med=font_med
        )

        # --- compute table top BEFORE drawing the title ---
        band_bottom = page_h - TOP_BAND_H
        y_table_top = band_bottom - GAP_BEFORE_TABLE

        # Title above the table (centered)
        c.setFont(font_bold, TABLE_TITLE_FS)
        c.setFillColor(NAVY)
        table_title = "Individual Investments"
        tw = c.stringWidth(table_title, font_bold, TABLE_TITLE_FS)
        x_center = (PAGE_WIDTH_PT - tw) / 2.0
        c.drawString(x_center, y_table_top + 25, table_title)

        # Table (anchored just below the band)
        _, th = tbl.wrapOn(c, content_w, 1)
        tbl.drawOn(c, LEFT_MARGIN, y_table_top - th)

        # Footer
        draw_footer_brand(c, page_h, font_med)

        c.showPage(); c.save()
        print(f"[ok] {out_path}")


if __name__ == "__main__":
    generate_consolidated_pages(EXCEL_PATH, OUTPUT_DIR)
